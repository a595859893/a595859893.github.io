<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>关于VAE</title>
      <link href="/2019/01/23/%E5%85%B3%E4%BA%8EVAE/"/>
      <url>/2019/01/23/%E5%85%B3%E4%BA%8EVAE/</url>
      <content type="html"><![CDATA[<p><a href="https://kexue.fm/archives/5253" target="_blank" rel="noopener">相关连接</a></p><h1 id="目前对自编码器的理解"><a href="#目前对自编码器的理解" class="headerlink" title="目前对自编码器的理解"></a>目前对自编码器的理解</h1><p>输入样本，经过隐藏层后输出同样的东西，实际上是将输入编码为了隐藏层的参数，使得隐藏层的参数和样本能够一一对应<br>即通过自编码器的不断学习，将样本一一编码至隐藏层向量中</p><h1 id="目前对VAE的理解"><a href="#目前对VAE的理解" class="headerlink" title="目前对VAE的理解"></a>目前对VAE的理解</h1><p>VAE中，一个样本对应的不再是一个隐藏层参数向量，而是向量的分布（通常我们假设为正态分布……可能是因为好算？）<br>每个样本对应一个自己<em>单独</em>的向量分布<br>训练的时候在这个分布中采样计算loss梯度<br>KL散度是为了保持分布的方差$\sigma$不会趋于零（正则项，使得模型更具有泛化性），而正常loss项则是保持分布的均值$\mu$向应该在的位置靠拢，二者共同作用以训练分布）<br>（所以之前以为loss中KL散度是为了让隐变量z服从正态分布的想法不是那么准确，虽然z在这种情况下能推出z确实是正态分布（这也是为什么我们可以依靠随机采样正态分布作为z的依据））<br>之所以对应$\sigma^2$参数算出的代表为$log \sigma^2$是因为$\sigma^2$恒为正，但是网络输出可能为负数，但是取对数后可正可负，就不用特殊处理负数情况了。</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
          <category> AI </category>
          
          <category> NeuralNetwork </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>阅读进度表</title>
      <link href="/2018/12/14/%E9%98%85%E8%AF%BB%E8%BF%9B%E5%BA%A6%E8%A1%A8/"/>
      <url>/2018/12/14/%E9%98%85%E8%AF%BB%E8%BF%9B%E5%BA%A6%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="未完备注"><a href="#未完备注" class="headerlink" title="未完备注"></a>未完备注</h1><p>卷积基础知识论文<br><a href="https://arxiv.org/pdf/1806.00178.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1806.00178.pdf</a><br><a href="https://arxiv.org/pdf/1611.05431.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1611.05431.pdf</a><br><a href="https://arxiv.org/pdf/1611.07718.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1611.07718.pdf</a><br><a href="https://arxiv.org/pdf/1409.4842.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1409.4842.pdf</a><br><a href="http://nooverfit.com/wp/inception深度学习家族盘点-inception-v4-和inception-resnet未来走向何方/" target="_blank" rel="noopener">http://nooverfit.com/wp/inception深度学习家族盘点-inception-v4-和inception-resnet未来走向何方/</a></p><p>强化学习<br><a href="http://karpathy.github.io/2016/05/31/rl/" target="_blank" rel="noopener">http://karpathy.github.io/2016/05/31/rl/</a><br><a href="https://www.nature.com/articles/nature14236" target="_blank" rel="noopener">https://www.nature.com/articles/nature14236</a><br><a href="https://gist.github.com/karpathy/a4166c7fe253700972fcbc77e4ea32c5" target="_blank" rel="noopener">https://gist.github.com/karpathy/a4166c7fe253700972fcbc77e4ea32c5</a></p><p>《神经科学》<br>当前145页<br>罗素《哲学问题》<br><a href="http://yuedu.163.com/book_reader/12420b29a4a2479e8313467ab5a000e9_4" target="_blank" rel="noopener">http://yuedu.163.com/book_reader/12420b29a4a2479e8313467ab5a000e9_4</a></p><h1 id="资料网站"><a href="#资料网站" class="headerlink" title="资料网站"></a>资料网站</h1><p><a href="https://www.oschina.net/" target="_blank" rel="noopener">https://www.oschina.net/</a><br><a href="https://github.com/explore" target="_blank" rel="noopener">https://github.com/explore</a><br><a href="https://yq.aliyun.com/" target="_blank" rel="noopener">https://yq.aliyun.com/</a><br><a href="https://www.ccf.org.cn/" target="_blank" rel="noopener">https://www.ccf.org.cn/</a><br><a href="https://en.wikipedia.org/wiki/List_of_computer_science_conferences" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/List_of_computer_science_conferences</a></p><h1 id="已完备注"><a href="#已完备注" class="headerlink" title="已完备注"></a>已完备注</h1>]]></content>
      
      
    </entry>
    
    <entry>
      <title>数据结构相关</title>
      <link href="/2018/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p><a href="https://www.zybang.com/question/6f70ed00e2fa62453476edf8668bb50b.html" target="_blank" rel="noopener">二叉树已知前序、后序，求中序</a><br><a href="https://blog.csdn.net/wang379275614/article/details/13990163/" target="_blank" rel="noopener">关键路径定义</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>pytorch相关</title>
      <link href="/2018/12/14/pytorch%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/12/14/pytorch%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h2 id="将one-hot转为token"><a href="#将one-hot转为token" class="headerlink" title="将one-hot转为token"></a>将one-hot转为token</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.eye(x.size(<span class="number">1</span>))[x.argmax(<span class="number">1</span>)]</span><br></pre></td></tr></table></figure><p>先生成单位向量，然后用花式索引选择其对应行<br>很赞的方法</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
          <category> AI </category>
          
          <category> NeuralNetwork </category>
          
          <category> pytorch </category>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>numpy与pandas相关</title>
      <link href="/2018/12/14/numpy%E4%B8%8Epandas%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/12/14/numpy%E4%B8%8Epandas%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>#<br><a href="https://pandas.pydata.org/" target="_blank" rel="noopener">pandas官方网站</a></p><h1 id="Pandas教程资料"><a href="#Pandas教程资料" class="headerlink" title="Pandas教程资料"></a>Pandas教程资料</h1><p><a href="http://pandas.pydata.org/pandas-docs/stable/10min.html" target="_blank" rel="noopener">10 Minutes to pandas</a> <a href="http://www.cnblogs.com/chaosimple/p/4153083.html" target="_blank" rel="noopener">（中文翻译）</a></p><h1 id="Pandas备忘"><a href="#Pandas备忘" class="headerlink" title="Pandas备忘"></a>Pandas备忘</h1><h2 id="DataFrame遍历"><a href="#DataFrame遍历" class="headerlink" title="DataFrame遍历"></a>DataFrame遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> data.iterrows():</span><br><span class="line">    <span class="keyword">pass</span> <span class="comment">#做点什么</span></span><br></pre></td></tr></table></figure><h2 id="DataFrame-缺失值填充"><a href="#DataFrame-缺失值填充" class="headerlink" title="DataFrame 缺失值填充"></a>DataFrame 缺失值填充</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.fillna()</span><br></pre></td></tr></table></figure><h1 id="个人需要注意的"><a href="#个人需要注意的" class="headerlink" title="个人需要注意的"></a>个人需要注意的</h1><p><a href="https://jingyan.baidu.com/article/93f9803fe29aece0e46f55cb.html" target="_blank" rel="noopener">Pandas填充缺失值</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>关于影印店病毒</title>
      <link href="/2018/12/05/%E5%85%B3%E4%BA%8E%E5%BD%B1%E5%8D%B0%E5%BA%97%E7%97%85%E6%AF%92/"/>
      <url>/2018/12/05/%E5%85%B3%E4%BA%8E%E5%BD%B1%E5%8D%B0%E5%BA%97%E7%97%85%E6%AF%92/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>跑了各种打印店，结果U盘一插上去总是中这个病毒<br>第一次的时候导致作业没办法按时交上去<br>后面虽然知道怎么解决了，这东西还是导致为了处理这货上课迟到了不少次<br>无法忍受后决定好好研究一番，看看能不能从根源上解决这个问题</p><p>不过在行动之前，先记录下如果被病毒隐藏了文件后怎么恢复<br>打开命令行，转至U盘所在，输入下面命令<br><code>attrib -s -h /s /d</code><br>即依靠<code>/s</code>递归取消<code>系统文件(-s)</code>和<code>隐藏文件(-h)</code>属性</p><h1 id="目前进度"><a href="#目前进度" class="headerlink" title="目前进度"></a>目前进度</h1><p>由于是最后一次感染病毒萌生了这个想法<br>之前看了看快捷方式，大概猜测到了可能的方式是通过快捷方式执行一个vbs程序<br>所以最后一次感染的时候并没有立即处理，而是关掉了反病毒软件，保留了病毒的vbs文件<br>打开源码好好看了下</p><p>相当混乱的代码<br>虽然没有学过vbs，不过大体上连蒙带猜外加百度推出了一些东西<br>然后推到一半发现这个病毒似乎早就有人已经在网上分析过了<br><a href="https://moozik.cn/archives/297/" target="_blank" rel="noopener">网址在这</a></p><p>对比了明文并且并且解析了下加密部分，似乎连代码都没有变过……<br>感觉就是一个相当古老的病毒在打印店里的古老样本<br>虽然存在各种后门，但是后门的IP都ping不通了<br>~（一个大胆的想法， 如果将后门网址的域名购买了的话……）~<br>（查了下域名，似乎都是在被使用的……）</p><h1 id="暂坑"><a href="#暂坑" class="headerlink" title="暂坑"></a>暂坑</h1>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Anaconda相关</title>
      <link href="/2018/10/26/Anaconda%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/10/26/Anaconda%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><p>为解决部分安装包无法下载的问题</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">清华大学开源镜像站</a></p><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><p><code>conda create -n env_name [list of packages]</code> 创建新的虚拟环境(参数<code>python=3</code>或<code>python=2</code>指定版本)</p><p><code>conda env remove -n env_name</code> 移除虚拟环境</p><p><code>conda env list</code> 列出当前虚拟环境表</p><p><code>conda activate env_name</code> 激活环境</p><p><code>conda install package_name</code> 安装包</p><p><code>conda upgrade --all</code>更新所有包</p><p>更多参考：<br><a href="https://www.jianshu.com/p/169403f7e40c" target="_blank" rel="noopener">Anaconda入门使用指南</a><br><a href="http://www.cnblogs.com/harvey888/p/5465452.html" target="_blank" rel="noopener">Anaconda多环境多版本python配置指导</a></p><h2 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h2><p>pandas tensorflow keras pytorch tushare flake8 numpy</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
          <category> AI </category>
          
          <category> NeuralNetwork </category>
          
          <category> anaconda </category>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>神经科学学习随意记录</title>
      <link href="/2018/09/28/%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6%E5%AD%A6%E4%B9%A0%E9%9A%8F%E6%84%8F%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/09/28/%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6%E5%AD%A6%E4%B9%A0%E9%9A%8F%E6%84%8F%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p><del>（懒得看latex公式有没有正确显示了……如果没有正确显示的话看看有没有时间弄弄吧）</del><br>然后就改掉了</p><p>尼氏染料除了神经元还会染色尼氏小体（粗面内质网），高尔基染料不会染色尼氏小体<br>细胞体，胞体，核周体是神经元”有核膨胀区”的不同称呼<br>神经元学说(建立者：Cajal)：神经元的突起不是连通的，它们通过接触而非连通传递信息。</p><ul><li>神经元（0.01~0.05mm）<ul><li>胞体<ul><li>细胞质<ul><li>细胞液</li><li>细胞器<ul><li>线粒体<ul><li>Kreba循环（ADP-&gt;ATP）</li></ul></li><li>粗面内质网（粗面ER）<ul><li>核糖体（合成蛋白质嵌在细胞膜或细胞器膜上）</li></ul></li><li>滑面内质网（滑面ER）<ul><li>有多种不同的类型和功能</li><li>与粗面ER相连部分，膜上蛋白质能正确折叠并形成三维结构</li></ul></li><li>高尔基体<ul><li>蛋白质”翻译“后进行大量化学修饰的场所</li><li>把转运到神经元不同部位（如轴突和树突）的蛋白质进行分类整理</li></ul></li><li>游离核糖体（合成蛋白质在神经元胞浆内）</li><li>多聚核糖体（几个游离核糖体附着在单链mRNA上）</li></ul></li></ul></li><li>细胞核<ul><li>染色体<ul><li>DNA</li></ul></li></ul></li><li>神经元膜<ul><li>厚约5nm</li><li>嵌有蛋白质<ul><li>一些可把膜内物质”泵”到膜外</li><li>其他蛋白质形成膜孔筛选能进入神经元的物质</li></ul></li><li>神经元重要特征：胞体、树突、轴突膜的蛋白质组成均不同</li></ul></li><li>细胞骨架（微管和微丝不断装配和解聚）<ul><li>微管<ul><li>直径越20nm</li><li>沿神经突起纵向排列</li><li>看似笔直中空的管子，管壁由围绕中心部分更小的瓣状链组成<ul><li>每条小链由微管蛋白（呈球状）聚合而成</li></ul></li><li>微管相关蛋白（MAPs）可把微管锚定在另一个微管或者神经元的其它部分。<ul><li>名为 tau 的轴突微管相关蛋白 病理学变化已知与阿尔茨海默病引起的痴呆有关</li></ul></li></ul></li><li>微丝<ul><li>直径5nm</li><li>遍布于神经元，在神经突起中更多</li><li>由两股细链盘绕而成，每股都是肌肉纤维蛋白的聚合物</li></ul></li><li>神经丝<ul><li>直径10nm</li><li>存在于身体每个细胞中，被称为中等纤维（仅在神经元中被称为神经丝）</li></ul></li></ul></li></ul></li><li>神经突起<ul><li>轴突<ul><li>可短于1mm，也可长于1m</li><li>一般只有一个，直径均一（若有分支，一般成直角衍生）</li><li>不含粗面ER，仅有少量游离核糖体</li><li>膜蛋白质组成基本不同于胞体膜</li><li>直径范围很广(人类在1~25微米，枪乌贼可达1mm)</li><li>轴突侧支<ul><li>返回侧支：与产生轴突的同一细胞或邻居细胞的树突连接的轴突侧枝</li></ul></li><li>轴突终末（终末扣）<ul><li>像一个膨胀的圆盘</li><li>不存在微管</li><li>包含了为数众多的膜质小泡，成为突触囊泡（直径约50nm）</li><li>面对突触的囊泡膜内附有特别高密度的蛋白质</li><li>含有大量线粒体，说明能量需求很高</li><li>末梢是和其他神经元或其它细胞的链接点，即突触</li><li>终末树：所有和同一区域树突或胞体组成的突触的分支的统称</li><li>神经支配：一个神经元和另一个细胞建立了突触联系。</li></ul></li><li>突触<ul><li>突触间隙：突触前膜和突触后膜之间的空间</li><li>突触传递：型号通过突触从一个神经元传递到另一个的传递</li><li>神经递质：可穿越突触间隙的化学信号（储存于末梢的突触囊泡内）</li></ul></li><li>轴浆运输（物质沿着轴突流动）<ul><li>慢速轴浆运输：每天1~10mm</li><li>快速轴浆运输：每天1000mm</li><li>顺向运输：囊泡沿着神经元微管通过驱动蛋白运输（ATP供能）</li><li>逆向运输<ul><li>分子机制类似于顺向运输，但通过动力蛋白运输</li><li>通常认为这个过程给胞体提供关于轴突末梢代谢需求变化的信号</li></ul></li></ul></li></ul></li><li>树突<ul><li>延伸距离很少超过2mm</li><li>树突树：单个神经元上树突的统称</li><li>树突侧支：树突树上的每个分支</li><li>受体：可探知突触间隙中的神经递质</li><li>树突棘<ul><li>接受某些突触输入</li><li>据说可以隔离某些突触激活引起的不同化学反应</li><li>突触活动类型和数量均可以影响棘的结构</li><li>认知能力有缺陷的人脑可呈现棘异常</li></ul></li><li>有多聚核糖体，表明突触传递实际上能指导某些神经元内部区域蛋白质的合成</li></ul></li></ul></li></ul></li></ul><ul><li>神经元的分类<ul><li>按突起数目（单极，双极，多极）</li><li>树突分类（椎体细胞，星形细胞）（棘状神经元，无棘神经元）</li><li>连接分类（初级感觉神经元，运动神经元，中间神经元）</li></ul></li></ul><ul><li>神经胶质细胞<ul><li>星形胶质细胞<ul><li>调节细胞外空间化学物质</li><li>也有神经递质受体，可以引发电和生化反应</li><li>严格控制一些物质的细胞外浓度</li></ul></li><li>成髓鞘胶质细胞<ul><li>少突胶质细胞和施万细胞<ul><li>提供一层层膜以隔离轴突（髓鞘）</li></ul></li></ul></li><li>其它非神经元细胞<ul><li>管室膜细胞：脑内充满液体的脑室衬里</li><li>小胶质细胞：吞噬细胞吞噬由死细胞或退化神经元及神经胶质细胞留下的残渣</li><li>脉管（动脉，静脉，毛细血管）</li></ul></li></ul></li></ul><p>电流不达到阈值不会产生动作电位<br>通过微电极不断注入电流时，会得到很多个动作电位<br>电流强度越大，动作电位发放频率越高（但存在绝对不应期和相对不应期）<br>动作电位强度似乎并不会随着电流增大而增大（根据图片）<br>Na通道开放时间约1ms，其不应期解释失活现象<br>Na通道通过半径来筛除K进入的可能<br>通道失活和恢复是通过连接的球的阻塞和下落完成的<br>动作电位传导速度随着轴突直径增加而加快</p><p>星形细胞产生动作电位较为稳定<br>锥形细胞产生动作电位开始很频繁，后来逐渐减慢（适应）<br>适应是可兴奋细胞的共性<br>某些细胞对稳定输入刺激的反应是产生有节奏可重复的爆发</p><p>运动神经元轴突一个神经电位可以引起其支配的肌肉细胞产生一个动作电位</p><p>突触囊泡 50nm<br>分泌颗粒 100nm</p><p>同一神经元中含有不同的神经递质<br>钙离子如何引发胞吐尚不明确<br>刺激时间较长时，结合于突触末梢细胞骨架的“储存池”的囊泡会释放和锚定到活性带<br>肽类释放需要高频串状动作电位（释放缓慢，50ms或更长时间）</p><ul><li>电压门控通道（受到电压刺激后改变通透性）</li><li>递质门控通道（与递质结合后改变通透性）<ul><li>兴奋性突触后电位:EPSP（同时打开Na+,K+）</li><li>抑制性突触后电位:IPSP（打开Cl-）</li></ul></li></ul><p>促代谢型受体-&gt;G蛋白-&gt;效应器-&gt;离子通道<br>促代谢型受体-&gt;G蛋白-&gt;效应器-&gt;酶-&gt;第二信使-&gt;其它酶</p><p>前膜也有受体，一般用于抑制神经递质的释放，有时也抑制合成<br>神经递质会通过扩散和（突触前神经末梢和神经胶质细胞的）重摄取被清除<br>突触后膜可能有几十到几千个递质门控通道，被激活数量取决于神经递质的释放量</p><ul><li>神经递质释放的基本单位是一个突触囊泡内容物。换句话说，EPSP是量子化的<ul><li>神经肌肉接头传递的量子分析揭示：一个突触前末梢的动作电位能触发大约200个突触囊泡释放，产生40mV或更大的EPSP</li><li>许多中枢神经系统的突触中，一个突触前动作电位仅引起一个囊泡的释放，产生的EPSP仅几毫伏</li><li>多数神经元执行更为精细的运算，需要许多EPSP叠加起来产生一个有意义的突触后去极化</li></ul></li></ul><ul><li>EPSP总和<ul><li>空间上是树突上不同突触同时产生的EPSPs叠加</li><li>时间上是同一个突触产生的间隔在1~15ms之内的一系列EPSP叠加</li></ul></li></ul><ul><li>假定树突在功能上像一个具有被动电活性的电缆（它缺乏电压门控离子通道）<ul><li>突触电流可以沿树突内部传递，或者跨树突膜(大部分跨膜流出)。</li><li>树突电缆上去极化的衰减参数是距离的函数\(V_x=V_o/E^{\chi/\lambda}\)</li></ul></li></ul><ul><li>许多神经元的树突被确定是非被动性的（即存在电压门控离子通道）<ul><li>这些电压门控通道不足以产生如轴突产生的可以完全扩布的动作电位</li><li>但是可以作为产生在树突远端较小突触后电位的重要放大器（可以增加电流促使突触信号朝胞体方向延伸）</li><li>某些树突上的钠通道可以将电信号从胞体向树突输出</li></ul></li></ul><ul><li>抑制性突触与兴奋性突触非常相似<ul><li>主要区别在于结合的神经递质不同</li><li>若膜电位是-65mV，看不到IPSP，但是神经元还是会被抑制（分流抑制）</li><li>IPSP可以从EPSP中减去，使得突触后神经元不易发放动作电位</li><li>分流抑制的作用是极大减少\(r_m\)，从而减少\(\lambda\)使得正电流流出膜外而不是在树突内流向峰电位起始区</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> NeuralScience </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Unity 单元测试坑</title>
      <link href="/2018/09/22/Unity-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%9D%91/"/>
      <url>/2018/09/22/Unity-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>写于Unity 2018版本</p><p>创建单元测试方式：<br>将<code>Project</code>目录切换到<code>Editor</code>上（如果没有则新建）<br>打开<code>Window -&gt; TestRunner</code><br>找到<code>EditMode</code>（如果要在游戏内测试，也可以选择<code>PlayMode</code>）<br>点击<code>Create Test Assembly Folder</code>创建测试文件夹<br>点击<code>Create Test Script in current floder</code>创建测试脚本</p><p>这样一个测试模块就创建好了，但是问题是这个模块不能够使用真实运行时引用的脚本<br>为了能够使用，需要进行以下步骤</p><p>在你需要引用到测试模块的脚本的文件夹下，<code>右键-&gt;Create-&gt;Assembly Definition</code>创建设定文件<br>回到你创建的测试文件夹，找到其中的设定文件<br>点击设定文件，在<code>Inspector</code>中找到<code>References</code>，添加之前创建的设定文件<br>打开VS，如果还是不能引用，就重建解决方案</p><p>到这应该就可以使用了</p>]]></content>
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>杂乱的连接收藏</title>
      <link href="/2018/09/05/%E6%9D%82%E4%B9%B1%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%94%B6%E8%97%8F/"/>
      <url>/2018/09/05/%E6%9D%82%E4%B9%B1%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%94%B6%E8%97%8F/</url>
      <content type="html"><![CDATA[<h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VS Code</a><br><a href="https://www.freedownloadmanager.org/" target="_blank" rel="noopener">Free Download Manager</a><br><a href="http://potplayer.daum.net/" target="_blank" rel="noopener">potplayer</a><br><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a><br><a href="https://typora.io/" target="_blank" rel="noopener">Typora</a><br><a href="https://notepad-plus-plus.org/[Everything](http://www.voidtools.com/" target="_blank" rel="noopener">notpad++</a><br><a href="https://www.cockos.com/licecap/" target="_blank" rel="noopener">LICEcap</a><br><a href="https://www.blender.org/" target="_blank" rel="noopener">Blender</a><br><a href="https://sai.yufan.me/" target="_blank" rel="noopener">SAI</a><br><a href="https://www.ccleaner.com/ccleaner" target="_blank" rel="noopener">CClear</a><br><a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a><br>UleadGIF(以前的连接挂掉了，未找到可信赖连接，备份于网盘)</p><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><p><a href="https://www.bilibili.com/video/av12465079" target="_blank" rel="noopener">【官方双语】想知道比特币（和其他加密货币）的原理吗？</a></p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>安装MinGW-w64编译器<br><a href="https://mingw-w64.org/doku.php/download" target="_blank" rel="noopener">https://mingw-w64.org/doku.php/download</a><br><a href="https://sourceforge.net/projects/mingw-w64/postdownload" target="_blank" rel="noopener">https://sourceforge.net/projects/mingw-w64/postdownload</a><br><a href="https://www.cnblogs.com/findumars/p/8289454.html" target="_blank" rel="noopener">https://www.cnblogs.com/findumars/p/8289454.html</a></p><p>安装Cmake<br><a href="https://cmake.org/" target="_blank" rel="noopener">https://cmake.org/</a></p><p>移除U盘“写保护”<br><a href="https://blog.csdn.net/asher_11/article/details/52801235" target="_blank" rel="noopener">https://blog.csdn.net/asher_11/article/details/52801235</a></p>]]></content>
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>tensorflow相关</title>
      <link href="/2018/09/05/tensorflow%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/09/05/tensorflow%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h1 id="Android-模型移植"><a href="#Android-模型移植" class="headerlink" title="Android 模型移植"></a>Android 模型移植</h1><p>将模型移植到手机端的时候，需要提供input和output的layer名字</p><p>tensorflow保存为pb模型的时候output名字在layer层里面会加入后缀，我们需要查看后缀之后输入它的输出名字<br>（如Dense层，名字为output的层的输出名字是output/Sigmoid</p><p>可以通过下述代码查看层的名字，这在将层移植到手机端上设置输入输出名的时候会很有用<br><code>[op for op in sess.graph.get_operations() if op.type == &quot;Const&quot;]</code></p><p>也可以在tensorflow里先生成图然后在tensorboard里查看，里面的名字也是一样的（相对更加方便看一些）</p><p>Android版本的tensorflow的feed输入是一维float数组，最后的long数组参数代表维数</p>]]></content>
      
      <categories>
          
          <category> AI </category>
          
          <category> NeuralNetwork </category>
          
          <category> tensorflow </category>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>python相关</title>
      <link href="/2018/09/05/python%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/09/05/python%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h1 id="pip上"><a href="#pip上" class="headerlink" title="pip上"></a>pip上</h1><p>pip install packagename –upgrade<br>升级某个包，以去除安装包的时候提示的版本不对的错误</p><p>python 字符串前加f，代表该字符串使用fomat格式，可以通过{XXXX}来嵌入变量和表达式</p><p><a href="https://www.biaodianfu.com/python-error-unable-to-find-vcvarsall-bat.html" target="_blank" rel="noopener">某cython错误</a></p><h1 id="vscode上"><a href="#vscode上" class="headerlink" title="vscode上"></a>vscode上</h1><p>使用flake8比pylint舒服一些……</p><p>“python.linting.flake8Args”: [“–max-line-length=248”]<br>提高flake8Args的line to long提示限制</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>keras 小技巧</title>
      <link href="/2018/09/05/keras%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/09/05/keras%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h1 id="层介绍"><a href="#层介绍" class="headerlink" title="层介绍"></a>层介绍</h1><p>RNN层的input一般是三维的array：0为样本，1为时序，2为当前时序的数据</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
          <category> AI </category>
          
          <category> NeuralNetwork </category>
          
          <category> keras </category>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>注意力模型之自己的胡说八道</title>
      <link href="/2018/08/25/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%A8%A1%E5%9E%8B%E4%B9%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E8%83%A1%E8%AF%B4%E5%85%AB%E9%81%93/"/>
      <url>/2018/08/25/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%A8%A1%E5%9E%8B%E4%B9%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E8%83%A1%E8%AF%B4%E5%85%AB%E9%81%93/</url>
      <content type="html"><![CDATA[<h1 id="事先提醒"><a href="#事先提醒" class="headerlink" title="事先提醒"></a>事先提醒</h1><hr><p>以下内容属于自己在尚<em>未完全理解</em>时，对于注意力模型自己<em>胡乱思考</em>得出来的<em>毫无根据</em>的<em>个人见解</em>，<em>看看就好，不要全信</em>。<br>可能含有<em>不专业</em>的<em>个人生造词</em></p><h2 id="以上为自己以后回顾和其它观看的人（如果有的话……？）的警告"><a href="#以上为自己以后回顾和其它观看的人（如果有的话……？）的警告" class="headerlink" title="以上为自己以后回顾和其它观看的人（如果有的话……？）的警告"></a>以上为自己以后回顾和其它观看的人（如果有的话……？）的警告</h2><p>可能参考的东西：<br><a href="http://www.cssn.cn/zhx/zx_kxjszx/201601/t20160126_2844813_1.shtml" target="_blank" rel="noopener">认识论的框架问题</a></p><h1 id="关于筛选信息"><a href="#关于筛选信息" class="headerlink" title="关于筛选信息"></a>关于筛选信息</h1><p>先引用一下人工智能框架问题</p><blockquote><p>必须让机器人知道哪些蕴含事件是相关的，而哪些是不相关的，并且学会忽略那些不相关的事件。<br>……<br>框架问题是要解释信息解封（Informationally Unencapsulated）的认知过程，即既能有效解决来自任何潜在认知域的信息，而又不至于受累于不得不明晰地把相关事物从不相关事物中筛选出来的繁重工作。</p></blockquote><p>(题外话：感谢 命运石之门0)</p><p>引用的目的是为了表达信息筛选的重要性，当需要的信息被精确的筛选出来，在之后的步骤中进行处理就会变得更加高效和准确</p><h1 id="关于RNN-Encoder-Decoder中的注意力模型"><a href="#关于RNN-Encoder-Decoder中的注意力模型" class="headerlink" title="关于RNN Encoder-Decoder中的注意力模型"></a>关于RNN Encoder-Decoder中的注意力模型</h1><p>引入注意力模型的RNN Encoder-Decoder为模型带来的更多的信息（因为要将每一步Encoder处理的向量都参与运算<br>而将这些信息筛选出有用的，则是注意力模型关键的地方，将这些信息输入，返回需要位置编号的注意权重<br>一般的解释中，是说权重越高的代表模型越关注这个位置的信息<br>而从另一个角度来看，也可以说是权重越低的信息被筛去的越多，只留下了对自己有用的信息</p><h1 id="关于注意力模型的想法"><a href="#关于注意力模型的想法" class="headerlink" title="关于注意力模型的想法"></a>关于注意力模型的想法</h1><p>看了网上的许多关于NLP的注意力模型的文章，似乎都将注意力模型输出的参数代表成“对应位置上的注意力”<br>从各种截图上来看，对应位置似乎就是对应的输入（词或者单字）<br>但是考虑到最后注意力模型输出是与RNN输出的语义向量进行乘法运算<br>所以注意力模型输出参数代表的应该是“对应位置及其之前的输入综合得到的语义向量的注意力”</p><p>为什么要关注这个呢？<br>首先是对应位置的向量只考虑的前面位置的数据，没有考虑后面位置的数据<br>但最重要的是，这个数据里面存在冗余<br>当然，并不否认这个向量里面存在着判断所需要的词汇的数据，这些数据是有必要存在的<br>但同时也存在着许多没有必要的数据</p><p>如果能够想到办法将这些没有必要的数据筛选出去，或许是一个提升效果的思路？<br>（不过可以真的要改的话模型会发生很大的变化，或许连RNN都不是了？）</p><p><del>然后是对位置的看法……<br>个人对这个位置表示的注意力有些排斥<br>其第一点就是原本变长十分方便的RNN为了引入注意力可能长度就要固定了（或许有不固定的方法？反正我是不知道了……）<br>其次考虑到句子本身长度是不定的，每个成分的长度也是不定的<br>如果某一个成分的长度发生了变化（或者注意力模型本身因为失误判断错位了一些），注意力模型的后续整个输出会不会因此造成错位？<br>（但愿这只是我不理解造成的误会吧……如果有证明或者证伪我这个观点的论文或者其它数据，我还是很希望知道的，至少能安心一些）</del><br>居然还有滑动窗口这种神奇的东西……</p>]]></content>
      
      <categories>
          
          <category> AI </category>
          
          <category> NeuralNetwork </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>机器学习的工具、文档以及资料记录</title>
      <link href="/2018/08/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B7%A5%E5%85%B7%E3%80%81%E6%96%87%E6%A1%A3%E4%BB%A5%E5%8F%8A%E8%B5%84%E6%96%99%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/08/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B7%A5%E5%85%B7%E3%80%81%E6%96%87%E6%A1%A3%E4%BB%A5%E5%8F%8A%E8%B5%84%E6%96%99%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p><a href="https://keras.io/" target="_blank" rel="noopener">keras</a>  <a href="https://keras-cn.readthedocs.io/en/latest/" target="_blank" rel="noopener">[中文]</a><br><a href="https://tushare.pro/" target="_blank" rel="noopener">Tushare Pro</a><br><a href="https://matplotlib.org/" target="_blank" rel="noopener">plt</a><br><a href="https://gym.openai.com/" target="_blank" rel="noopener">gym(openAI)</a></p><h1 id="可能有用的网站"><a href="#可能有用的网站" class="headerlink" title="可能有用的网站"></a>可能有用的网站</h1><p><a href="https://colab.research.google.com/" target="_blank" rel="noopener">Colaboratory(墙)</a><br>Google的免费AI训练网站，有账号就能够在上面使用一定的资源进行计算<br>嗯……有TPU<br><a href="http://rsarxiv.github.io/" target="_blank" rel="noopener">PaperWeekly</a><br>可以看到许多不错的论文推荐之类的东西<br>不过似乎没有在更新了，最新的一篇也只是2017年的东西了<br>但是里面的东西对个人还是挺有学习价值的<br><em>修正：<a href="http://paperweek.ly/" target="_blank" rel="noopener">PaperWeekly</a>新地址，似乎在这边更新了，似乎要注册才能看</em><br><a href="https://www.fast.ai/" target="_blank" rel="noopener">fastAI</a><br>据说是个好东西？不过还没看</p><h1 id="相关教程及文档"><a href="#相关教程及文档" class="headerlink" title="相关教程及文档"></a>相关教程及文档</h1><h2 id="gym"><a href="#gym" class="headerlink" title="gym"></a>gym</h2><p><a href="https://www.jianshu.com/p/cb0839a4d1d3" target="_blank" rel="noopener">https://www.jianshu.com/p/cb0839a4d1d3</a></p><h2 id="plt"><a href="#plt" class="headerlink" title="plt"></a>plt</h2><p><a href="http://www.cnblogs.com/wei-li/archive/2012/05/23/2506940.html#pyplot" target="_blank" rel="noopener">http://www.cnblogs.com/wei-li/archive/2012/05/23/2506940.html#pyplot</a></p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><a href="https://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">菜鸟基础教程</a><br>如果忽然忘了一些Python的基础操作可以在这里找<br><a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="noopener">《利用Python进行数据分析·第2版》</a><br>前几章详细地介绍了numpy等工具的利用，可以用于参考</p><h2 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h2><p><a href="https://keras-cn.readthedocs.io/en/latest/" target="_blank" rel="noopener">中文文档</a><br><a href="https://www.jianshu.com/p/6de246284f5c" target="_blank" rel="noopener">LSTM详解</a><br>因为是中文所以看着比较轻松，但是和英文相比有许多不全的地方<br>找不到或者不详尽的地方还是要看英文的文档<br><a href="https://keras.io/" target="_blank" rel="noopener">英文文档</a><br>英文，相对中文文档来说资料更全更新一些，在中文文档不够用的时候就要上了<br><a href="https://tensorflow.google.cn/" target="_blank" rel="noopener">tensorflow</a><br>含有基于keras的高级API教程和一些文档API<br>也有一些对基本模型的讨论和讲述<br>以后想要自定义keras的训练层的时候可能会需要在这里找文档<br>对于tensorflow的新功能也可以在这里多看看了解一下<br><a href="https://github.com/keras-team/keras/tree/master/examples" target="_blank" rel="noopener">官方例子</a><br>很棒的例子，代码简洁，有助于理解keras的使用和对部分网络结构的熟悉<br>不过建议只用来理解，真正做的时候看一下文档，因为部分例子里没有文档里的一些更方便的东西<br>（比如说在我写这篇的时候，seq2seq就没有使用embedding层，也没有忽略0数据<br>（不过更新似乎一直在继续，也许之后会看到更有效率的做法吧</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p><a href="https://zhuanlan.zhihu.com/p/34667893" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34667893</a><br><a href="https://blog.csdn.net/u010312436/article/details/78449632" target="_blank" rel="noopener">https://blog.csdn.net/u010312436/article/details/78449632</a></p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><p><a href="https://www.jianshu.com/p/75eeaee7f67d" target="_blank" rel="noopener">简要介绍</a></p><h2 id="seq2seq"><a href="#seq2seq" class="headerlink" title="seq2seq"></a>seq2seq</h2><p><a href="http://rsarxiv.github.io/2016/05/31/Sequence-to-Sequence-Learning-with-Neural-Networks-PaperWeekly/" target="_blank" rel="noopener">Sequence to Sequence Learning with Neural Networks</a><br>关于seq2seq的介绍</p><p><a href="http://rsarxiv.github.io/2016/06/01/Learning-Phrase-Representations-using-RNN-Encoder–Decoder-for-Statistical-Machine-Translation-PaperWeekly/" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder–Decoder for Statistical Machine Translation</a><br>里面涉及到的原论文中给出了GRU单元的算法以及概率的计算，可以较为清楚地了解GRU这个东西，还有seq2seq的原理</p><p><a href="https://github.com/Lsdefine/attention-is-all-you-need-keras/blob/master/rnn_s2s.py" target="_blank" rel="noopener">attention-is-all-you-need-keras</a><br>含有自定义程度较高的keras的seq2seq实现</p><h2 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h2><p><a href="https://arxiv.org/pdf/1409.0473.pdf" target="_blank" rel="noopener">NEURAL MACHINE TRANSLATION BY JOINTLY LEARNING TO ALIGN AND TRANSLATE</a><br>关于注意力模型的论文<br><a href="https://zhuanlan.zhihu.com/p/21287807" target="_blank" rel="noopener">知乎上对论文的中文介绍和理解</a></p><p><a href="https://blog.csdn.net/malefactor/article/details/50550211" target="_blank" rel="noopener">自然语言处理中的Attention Model：是什么及为什么</a><br>将引入注意力模型的原因和详细的解释一步步的说了出来，很清晰</p><p><a href="https://zhuanlan.zhihu.com/p/37835894" target="_blank" rel="noopener">attention模型方法综述</a></p><p><a href="http://ruder.io/deep-learning-nlp-best-practices/" target="_blank" rel="noopener">deep-learning-nlp-best-practices</a><br>比较全面的介绍</p><p><a href="https://blog.csdn.net/malefactor/article/details/50583474" target="_blank" rel="noopener">以Attention Model为例谈谈两种研究创新模式</a><br>对注意力模型的总结回顾和拓展</p><p><a href="https://blog.csdn.net/mpk_no1/article/details/72862348" target="_blank" rel="noopener">深度学习笔记——Attention Model（注意力模型）学习总结</a></p><p><a href="https://github.com/Xls1994/CDRextraction" target="_blank" rel="noopener">CDRextraction</a><br>似乎含有keras的attentionLayer实现</p><p><a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">AttentionIsAllYouNeed</a><br>不含有RNN和CNN的纯粹注意力模型论文<br>keras实践：<a href="https://github.com/Lsdefine/attention-is-all-you-need-keras/blob/master/transformer.py" target="_blank" rel="noopener">attention-is-all-you-need-keras </a><br>可能需要的参考：<br><a href="https://arxiv.org/pdf/1607.06450v1.pdf" target="_blank" rel="noopener">Layer Normalization</a><br><a href="https://www.zhihu.com/question/48820040" target="_blank" rel="noopener">你是怎样看待刚刚出炉的 Layer Normalisation 的？</a></p><h2 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h2><p>待填</p><h2 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h2><p><a href="https://zhuanlan.zhihu.com/p/41637843" target="_blank" rel="noopener">《知识图谱》专题论文解读</a><br>还没看，之后评价</p>]]></content>
      
      <categories>
          
          <category> AI </category>
          
          <category> NeuralNetwork </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>无脑邮件服务器</title>
      <link href="/2018/07/20/%E6%97%A0%E8%84%91%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/07/20/%E6%97%A0%E8%84%91%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>参考资料：<br><a href="https://www.itmanbu.com/docker-mail-server.html" target="_blank" rel="noopener">利用Docker自建多功能加密邮件服务器</a><br><a href="https://github.com/tomav/docker-mailserver" target="_blank" rel="noopener">docker-mailserver git网址</a></p><p>##安装<br>(安装docker的指令不太确定,如果不行的话上网找吧)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install docker -y</span><br><span class="line">sudo apt install docker-compose -y</span><br><span class="line">sudo apt install dovecot-core -y</span><br><span class="line">sudo docker pull tvial/docker-mailserver:latest</span><br><span class="line"></span><br><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository ppa:certbot/certbot</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install certbot</span><br></pre></td></tr></table></figure></p><h2 id="拉取配置文件"><a href="#拉取配置文件" class="headerlink" title="拉取配置文件"></a>拉取配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -o setup.sh https://raw.githubusercontent.com/tomav/docker-mailserver/master/setup.sh; chmod a+x ./setup.sh</span><br><span class="line">curl -o docker-compose.yml https://raw.githubusercontent.com/tomav/docker-mailserver/master/docker-compose.yml.dist</span><br><span class="line">curl -o .env https://raw.githubusercontent.com/tomav/docker-mailserver/master/.env.dist</span><br></pre></td></tr></table></figure><p>修改拉取后的.env文件进行配置，配置属性详情<a href="https://github.com/tomav/docker-mailserver" target="_blank" rel="noopener">见此</a></p><h2 id="DNS域名解析："><a href="#DNS域名解析：" class="headerlink" title="DNS域名解析："></a>DNS域名解析：</h2><p>sudo ./setup.sh config dkim<br>复制config/opendkim/keys/domain.tld/mail.txt下内容，将引号内字符串拼接后用于设置DNS<br>类型为TXT，记录名为mail._domainkey，记录值为拼接后字符串<br>类型为MX，记录名为@，记录值”mail.(你的域名)”(如”mail.abc.cn”,下面的域名以此为例)<br>类型为A，记录名为mail，记录值为(服务器的IP)</p><h2 id="证书-域名以”mail-abc-cn”-为例"><a href="#证书-域名以”mail-abc-cn”-为例" class="headerlink" title="证书(域名以”mail.abc.cn”,为例)"></a>证书(域名以”mail.abc.cn”,为例)</h2><p>certbot certonly –standalone -d mail.abc.cn<br>之后会要求你输入邮箱来获取安全信息等，填入邮箱即可。还会问你是否接受推送，这个看个人意愿选择吧。</p><p>证书续期<br><code>crontab -e</code>打开定时任务设置面板，按i进入编辑模式，粘贴进这段代码即：<br><code>0 5 * * 1 /usr/bin/certbot renew --quiet</code><br>可每周一凌晨5点0分给证书续期</p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p><code>docker-compose up -d mail</code></p><h2 id="注册邮箱-邮箱名字以”wuny-abc-cn“为例-密码以yourpassword为例"><a href="#注册邮箱-邮箱名字以”wuny-abc-cn“为例-密码以yourpassword为例" class="headerlink" title="注册邮箱(邮箱名字以”wuny@abc.cn“为例,密码以yourpassword为例)"></a>注册邮箱(邮箱名字以”<a href="mailto:wuny@abc.cn" target="_blank" rel="noopener">wuny@abc.cn</a>“为例,密码以yourpassword为例)</h2><p>sudo ./setup.sh email add <a href="mailto:wuny@abc.cn" target="_blank" rel="noopener">wuny@abc.cn</a> yourpassword</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>C# COM组件编写，并在C++上运行</title>
      <link href="/2018/06/02/C-COM%E7%BB%84%E4%BB%B6%E7%BC%96%E5%86%99%EF%BC%8C%E5%B9%B6%E5%9C%A8C-%E4%B8%8A%E8%BF%90%E8%A1%8C/"/>
      <url>/2018/06/02/C-COM%E7%BB%84%E4%BB%B6%E7%BC%96%E5%86%99%EF%BC%8C%E5%B9%B6%E5%9C%A8C-%E4%B8%8A%E8%BF%90%E8%A1%8C/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章使用的是<em>VS2017</em>，故以下内容操作均以<em>VS2017</em>版本为例子<br>部分代码在写本篇文章时与测试时所用代码略有不同，所以不保证能够生效<br>参考资料：<br><a href="https://blog.csdn.net/weiwenhp/article/details/7640936" target="_blank" rel="noopener">C++调用C# com组件:一个完整的的小例子</a><br><a href="http://www.cnblogs.com/JessieDong/archive/2009/07/21/1527632.html" target="_blank" rel="noopener">ClassInterface</a></p><hr><h1 id="新建并配置项目"><a href="#新建并配置项目" class="headerlink" title="新建并配置项目"></a>新建并配置项目</h1><p>新建一个<code>Visual C#/类库(.NET FrameWork)</code>项目，此处以<code>ComTest</code>作为项目名为例<br>在<em>解决方案资源管理器</em>中找到<code>ComTest/Properties/AssemblyInfo.cs</code>，将内部的<code>[assembly: ComVisible(false)]</code>由false改为true<br>打开<code>项目 - 属性</code>，在<code>生成 - 输出</code>中勾选”生成序列化程序集”</p><blockquote><p>可选：勾选<code>签名 - 为程序集签名</code>然后选择强名称密钥文件(方面起见本人测试时使用的是新建的,未勾选”使用密码保护密钥文件”的)</p></blockquote><hr><h1 id="编写注意事项"><a href="#编写注意事项" class="headerlink" title="编写注意事项"></a>编写注意事项</h1><p>##1、C++调用com组件中所有的功能<em>只能通过接口</em>来调用<br>    因此我们需要为暴露出来的类写一个<em>public接口</em>(通常接口名为”类名加上I前缀”)<br>    该接口需要有属性<code>[ComVisible(true)]</code></p><p>##3、需要为类和上述接口添加<a href="https://msdn.microsoft.com/zh-cn/library/system.guid(v=vs.80" target="_blank" rel="noopener">GUID</a>.aspx)<br>    GUI的生成可以在VS的<code>工具 - 创建GUID</code>栏中生成，格式为[GUID(“xxxxxxx-xxxx … xxxx”)]</p><p>生产环境卸下，建议</p><p>##1、接口的方法有属性<code>[DispId(X)]//X为不重复的整数</code></p><p>##2、类有属性<code>[ClassInterface(ClassInterfaceType.None)]</code></p><p>代码例子如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ComTest</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ComVisible(true)</span>]</span><br><span class="line">    [<span class="meta">Guid(<span class="meta-string">"80EB95B3-62C5-4469-B897-81BFA9D33447"</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ITestClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">DispId(1)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Guid(<span class="meta-string">"8FEBFADA-8442-4C50-A7FE-B788633EED8B"</span>)</span>]</span><br><span class="line">    [<span class="meta">ClassInterface(ClassInterfaceType.None)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span> : <span class="title">ITestClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>#编译和注册COM组件<br>通过<code>生成 - 生成ComTest</code>即可编译生成dll、tlb、pdb文件<br>由于VS在生成dll是会自动将代码注册至编译电脑，故COM组件的注册忽略，详情可见上方参考资料</p><p>#在C++中使用<br>将生成的dll、tlb、pdb<em>全部导入</em>C++项目中(导入后可能需要重新生成解决方案来更新引用，解决报错问题)<br>使用<code>#import &quot;.\ComTest.tlb&quot; named_guids raw_interfaces_only</code>进行引用，引用路径取决于三个文件在项目文件夹中的位置<br>通过<code>CoInitialize(NULL)</code>初始化COM组件<br>通过<code>ComTest::ITestClassPtr ptr;</code>创建一个类的类似指针的东西，注意<em>类型是”接口名+Ptr”</em><br>通过<code>ptr.CreateInstance(ComTest::CLSID_TestClass)</code>实例化一个类<br>(也可以通过<code>using namespace ComTest</code>省略前面的命名空间，此处的命名空间和COM组件在C#中定义的一致<br>通过<code>ptr-&gt;Add(a,b,&amp;c)</code>来调用类的方法，注意此处类型在C++中为long，而非C#中声明的int，且<em>不是通过return返回值，而是在末尾将值赋值给一个指针</em><br>(不过为什么这样资料上似乎也不太清楚)</p><p>调用示例如下<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include "stdafx.h"</span></span><br><span class="line"><span class="meta">#import ".\\ComTest.tlb" named_guids raw_interfaces_only</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">ComTest</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> a, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">CoInitialize(NULL);</span><br><span class="line">ITestClassPtr ptr;</span><br><span class="line">ptr.CreateInstance(CLSID_TestClass);</span><br><span class="line">ptr-&gt;Add(<span class="number">1</span>, <span class="number">2</span>, &amp;a);</span><br><span class="line"></span><br><span class="line">printf_s(<span class="string">"%ld"</span>, a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Language </category>
          
          <category> C# </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>C#WinFrom组件和3D动画资料</title>
      <link href="/2018/05/18/C-WinFrom%E7%BB%84%E4%BB%B6%E5%92%8C3D%E5%8A%A8%E7%94%BB%E8%B5%84%E6%96%99/"/>
      <url>/2018/05/18/C-WinFrom%E7%BB%84%E4%BB%B6%E5%92%8C3D%E5%8A%A8%E7%94%BB%E8%B5%84%E6%96%99/</url>
      <content type="html"><![CDATA[<p>C# 三维绘图<br>(opentk)[<a href="https://opentk.github.io/]" target="_blank" rel="noopener">https://opentk.github.io/]</a> ：简单易用<br>(ActiViz)[<a href="https://www.kitware.eu/product/activiz]" target="_blank" rel="noopener">https://www.kitware.eu/product/activiz]</a> ：从头开始</p><p>C# 3D引擎<br>(ogre)[<a href="https://www.ogre3d.org/]" target="_blank" rel="noopener">https://www.ogre3d.org/]</a> ：功能完善的“渲染模块”<br>(IrrLicht)[<a href="http://irrlicht.sourceforge.net/]" target="_blank" rel="noopener">http://irrlicht.sourceforge.net/]</a> ：轻量级，简单，但新东西支持不好，社区不够活跃</p><p>C# 自定义窗体控件<br>(窗体控件文档)[<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/winforms/controls/]" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/winforms/controls/]</a></p>]]></content>
      
      <categories>
          
          <category> Language </category>
          
          <category> C# </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>go 搭一个websocket</title>
      <link href="/2018/05/09/go-%E6%90%AD%E4%B8%80%E4%B8%AAwebsocket/"/>
      <url>/2018/05/09/go-%E6%90%AD%E4%B8%80%E4%B8%AAwebsocket/</url>
      <content type="html"><![CDATA[<p>#安装websocket库<br>最简单的方式是通过<code>go get -u golang.org/x/net</code>来安装<br>然而由于墙的原因这种方式似乎并不太好用<br>因此在(github上下载)[<a href="https://github.com/golang/net]后将文件放在`$GOPATH/src/golang.org/x/net`下（见git上介绍）" target="_blank" rel="noopener">https://github.com/golang/net]后将文件放在`$GOPATH/src/golang.org/x/net`下（见git上介绍）</a><br>然后执行指令<code>go install golang.org/x/net/websocket</code>即可安装</p>]]></content>
      
      <categories>
          
          <category> Language </category>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>构架演变（大概）</title>
      <link href="/2018/05/03/%E6%9E%84%E6%9E%B6%E6%BC%94%E5%8F%98%EF%BC%88%E5%A4%A7%E6%A6%82%EF%BC%89/"/>
      <url>/2018/05/03/%E6%9E%84%E6%9E%B6%E6%BC%94%E5%8F%98%EF%BC%88%E5%A4%A7%E6%A6%82%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>引用自某乎</p><blockquote><p>作者：得闲野鹤<br>链接：<a href="https://www.zhihu.com/question/25536695/answer/154614906" target="_blank" rel="noopener">https://www.zhihu.com/question/25536695/answer/154614906</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>我们在做一个访问量不大的项目的时候,一台服务器部署上一个应用+数据库也就够了.<br>那么访问量稍微大一点之后呢,为了解决用户反馈的卡,反应慢的情况,我们就上集群.架设nginx,部署多个服务,由nginx负责把请求转发到其他服务上,这样就解决了用户说的卡慢问题.<br>过了一段时间之后呢,我们发现数据库已经扛不住了,应用服务完好,数据库有时候宕机. 那这个时候呢,我们就上数据库读写分离,再架设几台数据库服务器,做主从,做分库分表. 然后数据库也不宕机了,服务又恢复了流畅.<br>又过了一段时间,公司事业增增日上,服务访问量越来越高,且大部分都是查询, 吸取之前宕机且为了办证数据库的健壮性,我们这个时候又加上了缓存, 把用户高频次访问的数据放到缓存里.<br>后来,项目功能越来越多,整个项目也愈发庞大,修改一个类就需要全盘上传,切换nginx重启,这样的发布流程越来越长,越来越繁杂.然后我们开始把模块拆分,用户信息分个项目,订单系统分一个项目.这样就达到了,用户模块代码修改的时候,只需要更新用户信息服务就好了.但是还是需要切换顶层的nginx.把要重启的服务的流量切到可用服务上. 这个时候我们就想到了RPC<br>那么RPC解决了什么呢? 所有的服务在启动的时候注册到一个注册机里面,然后顶层处理在接收到nginx的请求时,去注册机找一个可用的服务,并调用接口. 这样子呢,在不加新功能的时候,顶层处理服务我们就不需要动了? 那修改了用户信息项目的时候,我们只需要一个个更新用户信息项目的服务群就好了?<br>这样的话,无论是扩展还是服务的健壮性都妥妥的了?</p>]]></content>
      
      <categories>
          
          <category> Server </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>卷积网络笔记以及WaveNet理解相关资料</title>
      <link href="/2018/04/30/%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/04/30/%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/39022858" target="_blank" rel="noopener">来自知乎的原文</a><br>下面是自己的一些理解？<br>对于图像的操作可以写成矩阵的形式，作为<em>滤波器</em><br>这些<em>滤波器（filter）</em>会对特定的模式有高的激活（识别特定的曲线或者其它的模式）<br>训练卷积神经网络的时候，我们实际上是在训练每一格卷积层一系列的<em>滤波器</em><br>第二层的滤波器会将第一层的输出作为它的输出，来检测低阶特征的组合等情况<br>随着卷积层数的增加，组合的累计让神经网络能够检测的特征更加的复杂<br>这种方式与人类大脑的视觉信息处理模式相仿，都是由简单到复杂抽象</p><p>构建滤波器（训练）的方式是<em>修改滤波器矩阵的值（权重Weight）</em>,使其能识别特定的特征<br>修改依据是损失函数的输出，尽可能的让损失函数的值最小<br>使其变为一个最优化问题</p><p>WaveNet理解用相关资料<br>(卷积变种)[<a href="https://www.cnblogs.com/yangperasd/p/7071657.html]" target="_blank" rel="noopener">https://www.cnblogs.com/yangperasd/p/7071657.html]</a><br>(优化方法)[<a href="https://zhuanlan.zhihu.com/p/22252270]" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22252270]</a><br>(卷积训练公式推导)[<a href="https://zybuluo.com/hanbingtao/note/485480]" target="_blank" rel="noopener">https://zybuluo.com/hanbingtao/note/485480]</a></p>]]></content>
      
      <categories>
          
          <category> AI </category>
          
          <category> NeuralNetwork </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>go gin框架的一些坑</title>
      <link href="/2018/04/05/go-gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
      <url>/2018/04/05/go-gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>我们可以使用<code>c.Bind(&amp;abc)</code>来将传入的数据(json,xml,form等格式)赋值到abc这个struct中<br>但是要注意abc这个struct类型里，字母变量一定要<strong>首字母大写</strong><br>不然的话外部包无法访问这个变量，然后就无法对其赋值了<br>排查了4小时BUG的血的教训</p>]]></content>
      
      <categories>
          
          <category> Language </category>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>关于整数为什么不能用对角线来证明不可数</title>
      <link href="/2018/04/04/%E5%85%B3%E4%BA%8E%E6%95%B4%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%9D%A5%E8%AF%81%E6%98%8E%E4%B8%8D%E5%8F%AF%E6%95%B0/"/>
      <url>/2018/04/04/%E5%85%B3%E4%BA%8E%E6%95%B4%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%9D%A5%E8%AF%81%E6%98%8E%E4%B8%8D%E5%8F%AF%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>如题，存点连接<br><a href="https://zhuanlan.zhihu.com/p/19729557?utm_source=wechat_session&amp;utm_medium=social" target="_blank" rel="noopener">来自知乎</a></p><blockquote><p>实数的一种构造是「有理数列的极限」。</p></blockquote><h1 id="这里的数列是柯西数列，但我就不重复高等数学教材上的定义了。如果你学过或者手上有书，请翻书。如果没学过，那就随便看看吧。反正，柯西数列的定义中需要一种「距离」的概念。有了这个「距离」，柯西数列就是直观上越来越近的一系列点。在实数的定义中，这个距离很简单，就是两个有理数之前的差的绝对值。比如-3-14-和-3-1-之间的「距离」就是-0-04，而-3-3-1-3-14-3-141-3-1415-…-就是一个柯西数列。柯西有理数列的极限们就叫做实数。"><a href="#这里的数列是柯西数列，但我就不重复高等数学教材上的定义了。如果你学过或者手上有书，请翻书。如果没学过，那就随便看看吧。反正，柯西数列的定义中需要一种「距离」的概念。有了这个「距离」，柯西数列就是直观上越来越近的一系列点。在实数的定义中，这个距离很简单，就是两个有理数之前的差的绝对值。比如-3-14-和-3-1-之间的「距离」就是-0-04，而-3-3-1-3-14-3-141-3-1415-…-就是一个柯西数列。柯西有理数列的极限们就叫做实数。" class="headerlink" title="这里的数列是柯西数列，但我就不重复高等数学教材上的定义了。如果你学过或者手上有书，请翻书。如果没学过，那就随便看看吧。反正，柯西数列的定义中需要一种「距离」的概念。有了这个「距离」，柯西数列就是直观上越来越近的一系列点。在实数的定义中，这个距离很简单，就是两个有理数之前的差的绝对值。比如 3.14 和 3.1 之间的「距离」就是 0.04，而 3, 3.1, 3.14, 3.141, 3.1415, … 就是一个柯西数列。柯西有理数列的极限们就叫做实数。"></a>这里的数列是柯西数列，但我就不重复高等数学教材上的定义了。如果你学过或者手上有书，请翻书。如果没学过，那就随便看看吧。反正，柯西数列的定义中需要一种「距离」的概念。有了这个「距离」，柯西数列就是直观上越来越近的一系列点。在实数的定义中，这个距离很简单，就是两个有理数之前的差的绝对值。比如 3.14 和 3.1 之间的「距离」就是 0.04，而 3, 3.1, 3.14, 3.141, 3.1415, … 就是一个柯西数列。柯西有理数列的极限们就叫做实数。</h1><p>开头提到的题目中，题主在纠结：如果整数往左一直写下去是什么呢？在初等数学中，这仅仅是一个无穷整数数列，而且这个数列没有定义极限.<br>但是，我们现在来引入一个新的「距离」。如果一个有理数可以写成的形式，其中 p 和 q 不能被 2 整除，那么我们记 n 的「绝对值」为. 也就是说，如果 n 里包含一个 2 的次幂，那么幂次越高 n 就越「小」，幂次越低 n 就越「大」。在这个「绝对值」下，我们定义两个数的「距离」为.<br>我知道这个定义很让人纠结。如果你接受这个定义，那么将数字向左无穷写下去，即 这种形式，就有意义了。在新的「距离」下，比如 1, 01, 101, 1101, 01101, 101101 … 这样的数列就成了一个柯西数列。这个数列在新的「距离」下是收敛的。这些无穷数列的极限叫「2-进数」。比如 1, 11, 111, 1111, 11111 … 这个无穷数列，其极限是 -1.（我只是随便举个例子，请勿用初等数学来解释这个例子）。这样的做法自然适用于所有素数 p，相应的我们就有了 p-进数。<br>如题主所期望的，因为对给定的 p-进数，其位数是无限的，即每个 p-进数都对应一个无穷数列，所以可以用对角线方法证明，p-进数是不可数的。</p>]]></content>
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>go 关于mysql</title>
      <link href="/2018/04/04/go-%E5%85%B3%E4%BA%8Emysql/"/>
      <url>/2018/04/04/go-%E5%85%B3%E4%BA%8Emysql/</url>
      <content type="html"><![CDATA[<h2 id="检验连接正确性，需要使用sql-Ping"><a href="#检验连接正确性，需要使用sql-Ping" class="headerlink" title="检验连接正确性，需要使用sql.Ping()"></a>检验连接正确性，需要使用sql.Ping()</h2><p><a href="https://yq.aliyun.com/articles/178898?utm_content=m_29337" target="_blank" rel="noopener">来自阿里云</a></p><blockquote><p>执行sql.Open()并未实际建立起到数据库的连接，也不会验证驱动参数。第一个实际的连接会惰性求值，延迟到第一次需要时建立。用户应该通过db.Ping()来检查数据库是否实际可用。</p></blockquote><p>被坑过一次的坑……</p><h2 id="用Query的话记得读取数据"><a href="#用Query的话记得读取数据" class="headerlink" title="用Query的话记得读取数据"></a>用Query的话记得读取数据</h2><blockquote><p>同样的语句使用Exec和Query执行有巨大的差别。如上文所述，Query会返回结果集Rows，而存在未读取数据的Rows其实会占用底层连接直到rows.Close()为止。因此，使用Query但不读取返回结果，会导致底层连接永远无法释放。database/sql期望用户能够用完就把连接还回来，所以这样的用法很快就会导致资源耗尽（连接过多）。所以，应该用Exec的语句绝不可用Query来执行。</p></blockquote><p>需要注意的地方</p><h2 id="sql中，不需要每次调用Open，可以只有一个全局"><a href="#sql中，不需要每次调用Open，可以只有一个全局" class="headerlink" title="sql中，不需要每次调用Open，可以只有一个全局"></a>sql中，不需要每次调用Open，可以只有一个全局</h2><p><a href="https://www.zhihu.com/question/22197591/answer/20598968" target="_blank" rel="noopener">来自知乎 - 作者：汪亚军</a></p><blockquote><p>sql.Open 不会创建连接 ，只会创建一个DB实例，同时会创建一个go程来管理该DB实例的一个连接池（是长连接，但不是在Open的时候创建）。 在调用Begin()取一个连接，回滚或者提交得时候归还。如果你直接使用时Exec()执行，则每次会从连接池里面取出一个连接，到Exec执行完毕的时候归还。可以通过参数来调节连接池的大小。<br>golang sql包已经做了并发处理，自己通过channel的方式维护了一个连接池，所以没有必要在go程中加锁共享。<br>关于每次sql.Open，我觉得应该是一个不恰当的做法，这会导致连接得不到重用，并产生过多的短时间关闭的连接，给数据库造成没必要的压力。<br><a href="https://yq.aliyun.com/articles/178898?utm_content=m_29337" target="_blank" rel="noopener">来自阿里云</a><br>sql.DB对象是为了长连接而设计的，不要频繁Open()和Close()数据库。而应该为每个待访问的数据库创建<strong>一个</strong>sql.DB实例，并在用完前一直保留它。需要时可将其作为参数传递，或注册为全局对象。<br>这一抽象让用户不必考虑如何管理并发访问底层数据库的问题。当一个连接在执行任务时会被标记为正在使用。用完之后会放回连接池中。不过用户如果用完连接后忘记释放，就会产生大量的连接，极可能导致资源耗尽（建立太多连接，打开太多文件，缺少可用网络端口）。</p></blockquote><p>找到的许多资料都这么说，那么大概可以放心用了？</p><h2 id="重复调用Close-不会出现错误"><a href="#重复调用Close-不会出现错误" class="headerlink" title="重复调用Close()不会出现错误"></a>重复调用Close()不会出现错误</h2><p><a href="https://yq.aliyun.com/articles/178898?utm_content=m_29337" target="_blank" rel="noopener">来自阿里云</a></p><blockquote><p>rows.Close方法是幂等的，重复调用不会产生副作用，因此建议使用 defer rows.Close()来关闭结果集。</p></blockquote><p>安心用函数系列+1</p><h2 id="事务中第二次查询之前先将第一次查询结果读取完毕"><a href="#事务中第二次查询之前先将第一次查询结果读取完毕" class="headerlink" title="事务中第二次查询之前先将第一次查询结果读取完毕"></a>事务中第二次查询之前先将第一次查询结果读取完毕</h2><blockquote><p>因为事务保证在它上面执行的查询都由同一个连接来执行，因此事务中的语句必需按顺序一条一条执行。对于返回结果集的查询，结果集必须Close()之后才能进行下一次查询。用户如果尝试在前一条语句的结果还没读完前就执行新的查询，连接就会失去同步。这意味着事务中返回结果集的语句都会占用一次单独的网络往返。</p></blockquote><h2 id="Scan实参的方法"><a href="#Scan实参的方法" class="headerlink" title="Scan实参的方法"></a>Scan实参的方法</h2><p>不定参数的时候可以使用<code>rows.Columns()</code>来获取列名列表,不定类型的时候，可以使用<code>sql.RawBytes()</code>来获取类型<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cols, err := rows.Columns()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle this....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标列是一个动态生成的数组</span></span><br><span class="line">dest := []<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="built_in">new</span>(<span class="keyword">string</span>),</span><br><span class="line">    <span class="built_in">new</span>(<span class="keyword">uint32</span>),</span><br><span class="line">    <span class="built_in">new</span>(sql.RawBytes),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组作为可变参数传入Scan中。</span></span><br><span class="line">err = rows.Scan(dest...)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p><h2 id="关于prepare的详情"><a href="#关于prepare的详情" class="headerlink" title="关于prepare的详情"></a>关于prepare的详情</h2><p>(还没有看的资料)[<a href="http://go-database-sql.org/prepared.html]" target="_blank" rel="noopener">http://go-database-sql.org/prepared.html]</a><br>疑问在于，prepare什么时候用？全局注册后重复使用还是用的时候注册，用完销毁的使用？</p><h2 id="提高SQL执行效率的方法"><a href="#提高SQL执行效率的方法" class="headerlink" title="提高SQL执行效率的方法"></a>提高SQL执行效率的方法</h2><p><a href="https://stackoverflow.com/questions/19398773/inserting-rows-in-mysql-in-go-very-slow" target="_blank" rel="noopener">来自StackOverflow</a></p><blockquote><p>It’s an old question but still - better late than never; you’re in for a treat:<br>put all your data into a bytes.Buffer as tab-separated, newline terminated and unquoted lines (if the text causes problems, it has to be escaped first). NULL has to be encoded as \N.<br>Use <a href="http://godoc.org/github.com/go-sql-driver/mysql#RegisterReaderHandler" target="_blank" rel="noopener">http://godoc.org/github.com/go-sql-driver/mysql#RegisterReaderHandler</a> and register a function returning that buffer under “instream”. Next, call LOAD DATA LOCAL INFILE “Reader::instream” INTO TABLE … - that’s a very fast way to pump data into MySQL (I measured about 19 MB/sec with Go from a file piped from stdin compared to 18 MB/sec for the MySQL command line client when uploading data from stdin).<br>As far as I know, that very driver is the only way to LOAD DATA LOCAL INFILE without the need of a file.</p></blockquote><h2 id="避免Null值带来的麻烦，可以使用sql-NullString-sql-NullInt64等含null的类型"><a href="#避免Null值带来的麻烦，可以使用sql-NullString-sql-NullInt64等含null的类型" class="headerlink" title="避免Null值带来的麻烦，可以使用sql.NullString,sql.NullInt64等含null的类型"></a>避免Null值带来的麻烦，可以使用sql.NullString,sql.NullInt64等含null的类型</h2><p><a href="https://github.com/go-sql-driver/mysql/wiki/Examples" target="_blank" rel="noopener">来自github mysql官方插件说明</a></p><blockquote><p>Ignoring NULL values<br>Note: This might cause problems in Go 1.0 since the conversion from integer types to []byte is missing. The Issue is fixed in Go 1.1+<br>Maybe you already encountered this error: sql: Scan error on column index 1: unsupported driver -&gt; Scan pair: <nil> -&gt; <em>string<br>Normally you would use sql.NullString in such a case. But sometimes you don’t care if the value is NULL, you just want to treat it as an empty string.<br>You can do this with a small workaround, which takes advantage of the fact, that a nil-[]byte gets converted to an empty string. Instead of using </em>string as a rows.Scan(…) destination, you simple use <em>[]byte (or </em>sql.RawBytes), which can take the nil value:</nil></p></blockquote>]]></content>
      
      <categories>
          
          <category> Language </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go笔记-3</title>
      <link href="/2018/03/30/go%E7%AC%94%E8%AE%B0-3/"/>
      <url>/2018/03/30/go%E7%AC%94%E8%AE%B0-3/</url>
      <content type="html"><![CDATA[<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>并发是只一次做多件事情，但是同一时间只做一件事情<br>并行是一次做多件事情，并且这些事情在同一时间内都在处理</p><p>在函数前加入<code>go</code>关键字来新建一个并发的Goroutines<br>如<code>go funcName(1)</code><br>任何Gorountines都依附在main goroutines上，因此主进程结束时所有Goroutines都会立即结束，<strong>即使没有处理完毕</strong></p><h2 id="channels"><a href="#channels" class="headerlink" title="channels"></a>channels</h2><p>类型前加入chan关键字来声明，如<br><code>var a chan int</code><br><code>a := make(chan int)</code><br>前者<code>a == nil</code>，后者则定义了一个名为a的channel</p><p>channel的数据读写<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data := &lt;- a<span class="comment">//从a中读取数据，直到读取到数据才往下运行</span></span><br><span class="line">a &lt;- data <span class="comment">//向a中写入数据</span></span><br></pre></td></tr></table></figure></p><p>用法举例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"Hello world goroutine"</span>)</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> hello(done)</span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Println(<span class="string">"main function"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若channels写入数据但是该通道没有地方读取该数据，将会造成deadlock错误<br>参数传入时，可以使用<code>chan&lt;- int</code>，把传入的双向通道改为只写通道，函数内只能向通道写入数据，不能读取数据</p><p>通道中的每一条消息只能被收到一次，即使有多个函数试图接收，也只会有一个收到<br>可以使用’close(ch)’关闭ch通道，此时所有没有收到的都会收到关闭的数据<br>·v,ok&lt;-ch<code>的ok来判断ch通道是否是因为close而关闭，若关闭，收到的值为对应数据的零值</code>for v:=range ch`可以一直循环直到ch关闭</p><h2 id="buffered-channels"><a href="#buffered-channels" class="headerlink" title="buffered channels"></a>buffered channels</h2><p>发送时若buffer满了则会阻塞，受到时若buffer为空则阻塞<br>声明方法<br><code>ch := make(chan type, capacity)</code><br>capacity为buffer的容量，意味着发送时未被收接收的数据存放数量一旦高于就会阻塞<br>可以通过<code>len(eh)</code>获取还没有处理的数据，<code>cap(ch)</code>获取容量</p><h2 id="waitgroup"><a href="#waitgroup" class="headerlink" title="waitgroup"></a>waitgroup</h2><p>声明方法<code>var wg sync.WaitGroup</code><br>用<code>wg.Add(1)</code>添加计数，<code>wg.Down()</code>减少计数<br>用<code>wg.Wait()</code>等待直到计数归零<br>waitgroup作为实参传递的时候，需要加上<code>&amp;</code>防止函数内部传到的是副本而不是本身</p><h2 id="workpool"><a href="#workpool" class="headerlink" title="workpool"></a>workpool</h2><p>处理的任务的方式</p><blockquote><p>（并发1个）输入函数alloacate，将输入传递到’输入用channels’中<br>（并发n个）处理函数worker，从‘输入用channels’获取数据，处理后放在’输出用channels’<br>（并发1个）输出函数result，从’输出用channels’中获取数据用于输出</p></blockquote><p>其中’输入用channels’和’输出用channels’为buffered pool，可以储存一定量的数据供处理<br>n个worker函数使得任务可以一次并发处理多个</p><p>个人认为好处可能是是当其中1个任务工作量太大的时候，依旧可以处理其它工作量较小的任务，而不至于被大任务完全阻塞？</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s1 := &lt;-output1:</span><br><span class="line">fmt.Println(s1)</span><br><span class="line"><span class="keyword">case</span> s2 := &lt;-output2:</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output1,output2是channel<br>类似switch，但是是用来处理channel的，当有channel收到数据的时候，就会执行该分支，在这之前将会阻塞<br>若同时收到数据的有多个，则随机选择一个分支执行</p><p>分支可以使用default,代表没有任何一个case的channel收到了数据则执行<br>个人认为存在default分支的select不会造成阻塞，因为要么收到了数据随机执行分支，要么没有收到执行default，不会有等待的时刻</p><p>select中default的使用可以避免死锁<br>空的select会造成永久阻塞</p><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><p>临界区(Critical section)</p><blockquote><p>每个线程中访问临界资源的那段程序称为临界区（Critical Section）（临界资源是一次仅允许一个线程使用的共享资源）。每次只准许一个线程进入临界区，进入后不允许其他线程进入。不论是硬件临界资源，还是软件临界资源，多个线程必须互斥地对它进行访问。<br>摘自百度百科</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex.Lock()  </span><br><span class="line">x = x + <span class="number">1</span>  </span><br><span class="line">mutex.Unlock()</span><br></pre></td></tr></table></figure><p>mutex在Lock时会检测是否已经上锁了，如果有，则阻塞直到原先已经上锁的那边的锁的解除(即Unlock被执行)<br>可以防止因为多个Goroutines并发,同时修改同一个数据造成的数据错乱<br>和WaitGroup一样，传递Mutex变量需要使用<code>&amp;</code>来确保不同函数传入的是同一个而非拷贝，因为Mutex只有在同一个变量上锁的情况下才会阻塞</p><p>也可以使用channel达到与mutex相同的效果,令ch为capacity为1的buffered channel<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch&lt;-<span class="literal">true</span><span class="comment">//存在数据，其它函数内的ch只能阻塞直到这个数据被接收</span></span><br><span class="line">x = x+<span class="number">1</span></span><br><span class="line">&lt;-ch<span class="comment">//接收ch内的数据，其它函数内的ch现在可以解除阻塞来传入数据了</span></span><br></pre></td></tr></table></figure></p><h2 id="“仿造”Class"><a href="#“仿造”Class" class="headerlink" title="“仿造”Class"></a>“仿造”Class</h2><p>因为go里并没有提供’构造函数’功能，我们只能声明一个函数，假装它是构造函数:</p><blockquote><p>将struct用小写(比如说 a)设置为外部不可见,这样外部就不能直接声明变量来获得这个类型<br>构造一个函数(比如用Nwe命名)，生成一个a类型，并且为其赋值，然后返回这个a类型<br>由于外部只能通过这个函数生成到这种类型的数据，这个函数将充当构造函数</p></blockquote><h2 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h2><p>在函数或者方法前面添加<code>defer</code>关键词，可以让它在return之前才调用，但是保留当时参数的值，如<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printA</span><span class="params">(a <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"PrintA:"</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">a:=<span class="number">5</span></span><br><span class="line"><span class="keyword">defer</span> printA(a)</span><br><span class="line">a=<span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"Print:"</span>,a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Print: 10</span><br><span class="line">PrintA: 5</span><br></pre></td></tr></table></figure></p><p>多个defer采用栈(LIFO)后进先出的顺序执行</p><p>可用于有多个return分支但是又希望在return前进行统一动作的时候使用</p><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>自带有error接口，只要声明了<code>Error()</code>函数的类型，就可以作为错误输出数据<br>此时<code>Println()</code>函数会调用该数据的Error，输出其返回的string<br><code>errors.New(&quot;错误信息&quot;)</code>也可以用来创建新的错误数据<br><code>fmt.Errorf(&quot;错误信息,附带值:%d&quot;,10)</code>同样可以用来创建新的错误数据</p><p>通过类型断言来转化错误类型获得更多信息<br>比如说对于打开文件<code>f,err:=os.Opem(&quot;path/&quot;)</code>，可以断言err<br><code>if err, ok := err.(*os.PathError);ok</code>这样就可以用<code>err.path</code>获取到路径信息</p><p><code>func panic(interface{})</code>可以用来输出那些可能会导致程序无法继续的错误<br>调用该函数后,调用者函数将会被中止，未处理的deder的函数将会被处理<br>然后以同样的方式中止(调用(调用(panic函数)的函数)的函数)，逐级向外推进，直到推进到没有外层函数为止(即程序中止)<br>程序中止时，将输出调用panic函数的位置追踪。</p><p>可以在deder中调用<code>func recover() interface{}</code>来中止panic向外推进的过程<br>例如在<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverName</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r!= <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"recovered from "</span>, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么在调用<code>defer recoverName()</code>的函数不再向外层传递panic的影响（但调用函数本身依旧受到影响）<br>这使得panic只限制于一个范围内，而非让整个程序终止<br>recover只限于恢复同一个goroutine内的函数，无法在一个goroutine下恢复另一个goroutine造成的panic</p><p>runtime error也是内建的panic，所以也可以通过recover恢复</p><p>recover会中止错误路径追踪，如果需要追踪，则要在recover的函数内添加<code>debug.PrintStack()</code>函数来打印它</p><h2 id="一级函数"><a href="#一级函数" class="headerlink" title="一级函数"></a>一级函数</h2><p>(关于类型的分类资料)[<a href="http://rednaxelafx.iteye.com/blog/184199]" target="_blank" rel="noopener">http://rednaxelafx.iteye.com/blog/184199]</a><br>类型：规定了变量可以取的值得范围，以及该类型的值可以进行的操作。根据类型的值的可赋值状况，可以把类型分为三类： </p><blockquote><p>1、一级的（first class）。该等级类型的值可以传给子程序作为参数，可以从子程序里返回，可以赋给变量。大多数程序设计语言里，整型、字符类型等简单类型都是一级的。<br>2、二级的（second class）。该等级类型的值可以传给子程序作为参数，但是不能从子程序里返回，也不能赋给变量。<br>3、三级的（third class）。该等级类型的值连作为参数传递也不行。 </p></blockquote><p>所以一级函数就是能作为参数传递的函数</p><p>允许闭包，允许匿名函数，允许函数作为参数或者返回值</p>]]></content>
      
      <categories>
          
          <category> Language </category>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>go笔记-2</title>
      <link href="/2018/03/30/go%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2018/03/30/go%E7%AC%94%E8%AE%B0-2/</url>
      <content type="html"><![CDATA[<p>大部分例子和资料来自于<a href="https://golangbot.com/" target="_blank" rel="noopener">这里</a></p><h2 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h2><p>数组声明时<code>[]</code>放在类型前面，如<code>i := [5]int</code><br><code>i := [...]int{1,2,3}</code>可以自动判断数组大小<br>数组传参是按值传递的(但slice是按引用的，见下)，会创建副本，而非引用原来的数组<br>可以用<code>len(i)</code>获取数组长度<br>可以用<code>for index,value := range(i)</code>遍历数组<br>不同长度的数组类型是不同的</p><h2 id="关于slice"><a href="#关于slice" class="headerlink" title="关于slice"></a>关于slice</h2><p><a href="https://www.zhihu.com/question/27161493/answer/153494730" target="_blank" rel="noopener">参考资料</a></p><p>slice内部有三个变量<code>len</code>,<code>cap</code>,<code>ptr</code><br>ptr是指向底层数组的指针<br>cap是ptr的容量<br>len是slice的长度(含有元素的个数)</p><p>没有元素的slice类型是nil，cap和len为0<br><code>a:=i[1:2]</code>切片slice，切出来的部分会随着原数组对应值改变而改变<br>可以用<code>i[:]</code>代表整体的切片<br><code>b:=make([]int,0,10)</code>也可以用来创建slice，此时<code>len(a)</code>为0,<code>cap(a)</code>为10</p><p><code>a = append(a,1,2,3,4)</code>可以对切片添加数据,或<code>b = append(b,a...)</code>来添加切片a的元素值到b</p><p>slice长度变化(扩容)</p><blockquote><p>如果新的大小是当前大小2倍以上，则大小增长为新大小<br>否则循环以下操作：如果当前大小小于1024，按每次2倍增长，否则每次按当前大小1/4增长。直到增长的大小超过或等于新大小。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">b := <span class="built_in">append</span>(a[<span class="number">0</span>:<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">b[<span class="number">0</span>]++</span><br><span class="line">fmt.Println(a,b)</span><br></pre></td></tr></table></figure><p>输出<code>[1] [2 1]</code><br>切片的cap是被切片数组起始元素到数组末尾的元素个数(1-0=1)，而len在此处是切片的长度(1-0=1)<br>添加元素后len+1&lt;cap，需要扩容<br>扩容之后由于内存地址重新分配，值为原先的拷贝而非引用，因此修改值<strong>不会</strong>反映到原数组上</p><p>由于append的长度不需要变化的时候ptr还是原来的值，这时候append是直接通过修改ptr上的元素来实现的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">x:=<span class="built_in">append</span>(a,<span class="number">1</span>)</span><br><span class="line">y:=<span class="built_in">append</span>(a,<span class="number">2</span>)</span><br><span class="line">fmt.Println(x,y)</span><br></pre></td></tr></table></figure></p><p>输出<code>[0 0 0 2] [0 0 0 2]</code><br>可见x本来应该是1的值因为y的append变成了2<br>因为a不需要扩容(len(a)+1=3+1&lt;=5=cap(a)),x,y指向的还是a的ptr,append在a的len往后一位修改内存<br>append不会改变传入数组的属性，a的len不变，因此两次append都是往a的第四个元素修改<br>如果第3句改为<code>y:=append(x,2)</code>就不会出现上述的问题,因为x的len是4,会后移一位修改,此时y的输出将会是<code>[0 0 0 1 2]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">b := a[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">c := <span class="built_in">append</span>(b, <span class="number">1</span>)</span><br><span class="line">fmt.Println(a, b, c)</span><br></pre></td></tr></table></figure><p>输出<code>[1 1 3 4] [1] [1 1]</code><br>也同样反应了上述观点,<code>len=1-0=1</code>,<code>cap=4-0=4</code>,<code>len+1&lt;cap</code>,没有扩容<br>直接往b的len的下一位修改，而b的ptr指向的是a的第0个元素,所以修改的是a的第1个元素，即a的元素2被改成了1</p><p>嗯……总之go的slice使用的时候要注意</p><h2 id="可变参函数"><a href="#可变参函数" class="headerlink" title="可变参函数"></a>可变参函数</h2><p>在类型前面加上<code>...</code>(限最后一个参数使用)<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(num <span class="keyword">int</span>,nums ...<span class="keyword">float64</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(nums[<span class="number">0</span>],<span class="built_in">len</span>(nums))</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时传入的nums类型为 []float64，或者说float的slice</p><p>f2可以接受多个float64参数，或者一个slice(需要在后面加上<code>...</code>,一个语法糖)<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f2(<span class="number">1</span>,<span class="number">1.1</span>,<span class="number">1.2</span>,<span class="number">1.3</span>,<span class="number">1.4</span>)</span><br><span class="line"></span><br><span class="line">a:=[...]<span class="keyword">float64</span>&#123;<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>&#125;</span><br><span class="line">f2(<span class="number">1</span>,a[<span class="number">0</span>:<span class="number">3</span>]...)</span><br></pre></td></tr></table></figure></p><p>如果传入了slice,函数内部对slice内元素的修改将会反映到原来的slice上（可以理解为对指针的修改？）</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">b := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">a[<span class="string">"abc"</span>] = <span class="number">1</span></span><br><span class="line">value,ok := a[<span class="string">"def"</span>]<span class="comment">//ok==false</span></span><br><span class="line"><span class="built_in">delete</span>(a,<span class="string">"abc"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(a))</span><br></pre></td></tr></table></figure><p>map是引用类型</p><h2 id="string-和-rune"><a href="#string-和-rune" class="headerlink" title="string 和 []rune"></a>string 和 []rune</h2><p>string以十六进制编码，下标对应1个字节，以下标访问时，如果是unicode且占2字节的东西用%c显示的将不是预期的结果<br>rune是int32的别名，rune数组转换的string，下标对应1个字符（不论编码），用%c即使是2字节的unicode也可以正常显示<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s:=<span class="string">"Hello world"</span></span><br><span class="line">a:=[]<span class="keyword">rune</span>(s)</span><br></pre></td></tr></table></figure></p><p>遍历字符<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s:=<span class="string">"Hello World"</span></span><br><span class="line"><span class="keyword">for</span> index,<span class="keyword">rune</span> := <span class="keyword">range</span> s&#123;</span><br><span class="line"><span class="comment">//index代表该字符占的字节数，rune代表该字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>[]rune和[]byte可以转string<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byteSlice := []<span class="keyword">byte</span>&#123;<span class="number">0x43</span>,<span class="number">0x61</span>,<span class="number">0xC3</span>,<span class="number">0XA9</span>&#125;</span><br><span class="line">str1:=<span class="keyword">string</span>(byteSlice)</span><br><span class="line"></span><br><span class="line">runeSlice := []<span class="keyword">rune</span>&#123;<span class="number">0x0053</span>, <span class="number">0x0065</span>, <span class="number">0x00f</span>1, <span class="number">0x006f</span>, <span class="number">0x0072</span>&#125;</span><br><span class="line">str2:=<span class="keyword">string</span>(runeSlice)</span><br></pre></td></tr></table></figure></p><p>string的utf8编码下字符长度用<code>utf8.RuneCountInString(s)</code><br>string是不可修改量，可以通过下标获取，但是不能修改，要修改可以先转为[]rune,改完后再转回string</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>···<br>var a *int<br>//a==nil</p><p>b:=1<br>c:=&amp;b<br>*c++<br>···</p><p>对数组的指针传参<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr *[3]<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时arr[0]是(*arr)[0]的缩写</p><p>一般更习惯用slice进行数组修改，而非数组指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func modify(sls []int)&#123;</span><br><span class="line">sls[0] = 90</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用方式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:=[<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">modify(a[:])</span><br></pre></td></tr></table></figure></p><p><strong>不支持</strong>指针修改，<code>p++</code>之类的操作是不行的</p><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>定义和使用<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName, lastName <span class="keyword">string</span></span><br><span class="line">    age, salary         <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emp2 := Employee&#123;<span class="string">"Thomas"</span>, <span class="string">"Paul"</span>, <span class="number">29</span>, <span class="number">800</span>&#125;</span><br><span class="line"><span class="keyword">var</span> a Employee</span><br></pre></td></tr></table></figure><p>匿名struct<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">emp3 := <span class="keyword">struct</span> &#123;</span><br><span class="line">        firstName, lastName <span class="keyword">string</span></span><br><span class="line">        age, salary         <span class="keyword">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        firstName: <span class="string">"Andreah"</span>,</span><br><span class="line">        lastName:  <span class="string">"Nikola"</span>,</span><br><span class="line">        age:       <span class="number">31</span>,</span><br><span class="line">        salary:    <span class="number">5000</span>,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>对于struct指针，可以用<code>a.abc</code>代替<code>(*a).abc</code>来访问<code>a</code>中的属性<code>abc</code></p><p>对于struct嵌套，若未声明变量名(即定义如下时,假设Abc为另一个struct，有def属性)<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">Abc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则可以用<code>a.def</code>代替<code>a.Abc.def</code>来访问a中<code>struct Abc</code>中的<code>def</code>变量（下述的’方法’同理）</p><p>当成员变量都可相等比较的时候，struct才可以相等比较，当所有成员都相等时认为相等</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">displaySalary</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"Salary of %s is %s%d"</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以定义一个Employere的方法，但是这样的方法修改变量不会影响到原变量，传入的e是原来e的拷贝<br>要影响需要用指针，即<code>func (e *Employee) displaySalary()</code><br>对于这种形式的方法，<code>e.dispaleSalary()</code>将是<code>(&amp;e).displaySalary()</code>的简写</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>定义<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">interface</span>&#123;</span><br><span class="line">abc()[]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当一个struct实现了所有接口的方法，它将会<strong>自动</strong>应用接口，而不需要自己显式地添加什么</p><p>实现了接口的struct可以被赋值给接口类型，如果a变量的类型实现了A接口，那么就可以<code>var b A:=a</code></p><p>任何数据都应用了空接口<code>interface{}</code>（没有任何方法的接口），所以可以用空接口来为属性传入任何类型的参数<br>可以利用<code>a := i.(int)</code>来断言传入的参数i类型为int，如果不是则报运行时错误<br>可声明ok变量，这样就不会报运行时错误，然后根据ok变量的值做进一步的判断<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertion</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">s,ok:=i.(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;<span class="comment">//是int类型</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>字面量作为这种函数的参数的时候，将会转化为默认类型，传入参数为字面常量<code>8</code>时，断言int是true，int8为false<br>可以在switch中使用断言,断言的类型判断也可以是接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> i.(<span class="keyword">type</span>)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口可以嵌套，可以声明一个接口，里面嵌套另一个接口<br>未赋值的接口变量为nil</p>]]></content>
      
      <categories>
          
          <category> Language </category>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>go笔记-1</title>
      <link href="/2018/03/30/go%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2018/03/30/go%E7%AC%94%E8%AE%B0-1/</url>
      <content type="html"><![CDATA[<p>大部分资料来自于<a href="https://golangbot.com/" target="_blank" rel="noopener">这里</a></p><h2 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h2><p>声明方式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b, c <span class="keyword">int</span> = <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">d, e := <span class="number">4</span>, <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">f     = <span class="number">6</span></span><br><span class="line">g <span class="keyword">int</span> = <span class="number">7</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="关于常量"><a href="#关于常量" class="headerlink" title="关于常量"></a>关于常量</h2><p>对于没有设定类型的<em>常量</em>，是没有类型的<br>比如说<code>const i = 1</code><br>可以有<code>var a int = i</code>或者<code>var b int8=i</code><br>在需要的地方它才会转化类型，就像是字面常量一样</p><h2 id="关于函数"><a href="#关于函数" class="headerlink" title="关于函数"></a>关于函数</h2><p>函数可以有多个输出（此时需要用括号括起来），下划线<code>_</code>可用来抛弃一些函数的返回值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a,b <span class="keyword">int</span>)</span><span class="params">(c,d <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">c=a</span><br><span class="line">d=b</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_,c = f(<span class="number">1</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>此时c为3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 关于包</span><br><span class="line">只有首字母大写的函数和变量才能够在被其他包引用时调用</span><br><span class="line">包内可以声明</span><br><span class="line">```go</span><br><span class="line">func init()&#123;</span><br><span class="line">//do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行包的初始化，<code>init()</code>函数会在包内变量初始化完毕后执行<br>一个包可以有多个<code>init()</code>，不管是在同一个文件内还是放在包内的不同文件中<br>即使被import多次，<code>init()</code>也只会执行一次，</p><p>可以在包前面加入下划线，代表我们需要这个包的<code>init()</code>，但是不一定在代码里用上这个包<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br></pre></td></tr></table></figure></p><p>用下划线<code>_</code>赋值包内函数或变量，则可以在开发时暂时禁用未使用包的错误，等真的使用的时候再删除</p><h2 id="关于if"><a href="#关于if" class="headerlink" title="关于if"></a>关于if</h2><p>else和花括号必须在同一行，除非你用了分号<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>if内可以塞语句，语句会在条件判断前执行<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x:=<span class="number">10</span>;x&gt;=<span class="number">10</span>&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="关于循环"><a href="#关于循环" class="headerlink" title="关于循环"></a>关于循环</h2><p>for 内可以只塞条件，类似其他语言的while一样使用<br>没有条件代表无限循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x==<span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">//break when x==1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//infinite</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于switch"><a href="#关于switch" class="headerlink" title="关于switch"></a>关于switch</h2><p>switch内可以塞语句，语句会在条件判断前执行<br>case中会自动在结尾加上break（对于不想自动添加break的，可以在那一段case内末尾加入fallthrough关键字）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x:=<span class="number">1</span>; x&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>:</span><br><span class="line"><span class="comment">//x is 1 or 2 or 3</span></span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显式下厨break也不会报错，但是只会跳出switch判断，如<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x:=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">switch</span> x&#123;</span><br><span class="line"><span class="keyword">case</span>:<span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只会跳出break而不是for，依旧会无限循环下去<br>要跳出for,可以这样<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x:=<span class="number">1</span></span><br><span class="line">myloop: <span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">switch</span> x&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">break</span> myloop</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>case条件 <strong>不一定</strong> 是常量,switch为空的时候，匹配条件为true的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x&lt;<span class="number">2</span>:</span><br><span class="line"><span class="comment">//x is less than 2</span></span><br><span class="line"><span class="keyword">case</span> x&lt;<span class="number">3</span>:</span><br><span class="line"><span class="comment">//x is in range [2,3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Language </category>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>VSCode go 插件安装</title>
      <link href="/2018/03/29/VSCode-go-%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
      <url>/2018/03/29/VSCode-go-%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>由于部分插件受限于国内网络原因无法下载安装，如果没有科学上网的话，可以尝试以下方式<br>来自<a href="https://zhuanlan.zhihu.com/p/22241891" target="_blank" rel="noopener">这里</a><br>在go工作目录下的<code>src/golang.org/x</code>中克隆<code>https://github.com/golang/tools</code>仓库<br>(路径：src/golang.org/x/tools/各种文件)<br>然后执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go get -u -v github.com/rogpeppe/godef</span><br><span class="line">go get -u -v github.com/golang/lint/golint</span><br><span class="line">go get -u -v github.com/lukehoban/go-outline</span><br><span class="line">go get -u -v sourcegraph.com/sqs/goreturns</span><br><span class="line">go get -u -v github.com/tpng/gopkgs</span><br><span class="line">go get -u -v github.com/newhook/go-symbols</span><br><span class="line">go get -u -v golang.org/x/tools/cmd/guru</span><br></pre></td></tr></table></figure></p><p>部分可能下载失败，这部分需要使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go install github.com/golang/lint/golint</span><br><span class="line">go install sourcegraph.com/sqs/goreturns</span><br><span class="line">go install golang.org/x/tools/cmd/gorename</span><br><span class="line">go install github.com/newhook/go-symbols</span><br><span class="line">go install golang.org/x/tools/cmd/guru</span><br></pre></td></tr></table></figure></p><p>个人尝试安装glint还是失败，于是去<br><a href="https://github.com/golang/lint" target="_blank" rel="noopener">https://github.com/golang/lint</a><br>直接将东西下载下来放在<code>src/golang.org/x</code>下(文件夹名字是lint)<br>再执行<code>go install github.com/golang/lint/golint</code></p><p>如果其他库也安装失败，应该也可以在git上找到对应的库用类似的方法解决？(不太确定)</p>]]></content>
      
      <categories>
          
          <category> Language </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>无脑配服务器/Nginx/MySQL/mongoDB/go/redis</title>
      <link href="/2018/03/28/%E6%97%A0%E8%84%91%E9%85%8D%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx-MySQL-mongoDB-go-redis/"/>
      <url>/2018/03/28/%E6%97%A0%E8%84%91%E9%85%8D%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx-MySQL-mongoDB-go-redis/</url>
      <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install bison ed gawk gcc libc6-dev make -y</span><br><span class="line">sudo apt-get install nginx -y</span><br><span class="line">sudo apt-get install mongodb-server -y</span><br><span class="line">sudo apt-get install redis-server -y</span><br><span class="line">sudo apt-get install mysql-server -y</span><br><span class="line">sudo apt-get install golang -y</span><br></pre></td></tr></table></figure><p>MYSQL安装需要输入root账户的密码</p><hr><hr><h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>创建nginx用权限账户 www（或者在配置文件中修改user为已存在用户）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/sbin/groupadd www</span><br><span class="line">sudo /usr/sbin/useradd -g www www</span><br></pre></td></tr></table></figure></p><p>(可能会报sudo: unable to resolve host,这只是warning,可以不用管，下同)</p><p>修改配置文件（参考文件中有参考网址可以查看参数的作用）<br><code>sudo vim /etc/nginx/nginx.conf</code></p><blockquote><p>/etc/nginx/conf.d/*.conf;<br>/etc/nginx/sites-enabled/*;<br>这两个是配置文件中带有的目录，网站的参数也可以在这里进行修改</p></blockquote><blockquote><p>默认在”/etc/nginx/sites-enabled/default”中存在80端口的配置<br>如果自己需要修改80端口的话，可以直接修改这个文件，或者删掉自己重新配置</p></blockquote><p>重启nginx适用配置</p><h2 id="sudo-service-nginx-restart"><a href="#sudo-service-nginx-restart" class="headerlink" title="sudo service nginx restart"></a><code>sudo service nginx restart</code></h2><hr><h2 id="MySql配置"><a href="#MySql配置" class="headerlink" title="MySql配置"></a>MySql配置</h2><p>登陆mysql并创建数据库NEST,远程访问用户bird，并授权<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql -u username -p password</span><br><span class="line">create database NEST</span><br><span class="line">CREATE USER &apos;bird&apos;@&apos;%&apos; IDENTIFIED BY &apos;password here&apos;;</span><br><span class="line">GRANT ALL ON NEST.* TO &apos;bird&apos;@&apos;%&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></p><p>修改配置文件<br><code>sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</code><br>修改bind-address为0.0.0.0</p><p>重启mysql适用配置<br><code>sudo service mysql restart</code></p><hr><hr><h2 id="mongoDB配置"><a href="#mongoDB配置" class="headerlink" title="mongoDB配置"></a>mongoDB配置</h2><p>（记得在防火墙打开27017端口）</p><p>添加用户数据<br>（创建了超级权限的root用户，和一个只读写nest数据库的bird用户）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br><span class="line">use admin</span><br><span class="line">db.createUser(&#123;user:&quot;root&quot;,pwd:&quot;password here&quot;,roles:[&quot;root&quot;]&#125;)</span><br><span class="line">use nest</span><br><span class="line">db.createCollection(&quot;nest&quot;)</span><br><span class="line">db.createUser(&#123;user:&quot;bird&quot;,pwd:&quot;password here&quot;,roles:[&#123;role:&quot;readWrite&quot;,db:&quot;nest&quot;&#125;]&#125;)</span><br></pre></td></tr></table></figure></p><p>然后退出mongo<br><a href="https://docs.mongodb.com/manual/reference/method/db.createUser/#db.createUser" target="_blank" rel="noopener">用户添加参考</a><br><a href="https://docs.mongodb.com/manual/reference/built-in-roles/#built-in-roles" target="_blank" rel="noopener">内置权限参考</a><br><a href="https://docs.mongodb.com/manual/core/security-user-defined-roles/#user-defined-roles" target="_blank" rel="noopener">自定义权限参考</a></p><p>修改配置文件<br><code>sudo vim /etc/mongodb.conf</code><br>注释”bind_ip=127.0.0.1”一行,以允许远程访问<br>取消注释”auth = true”一行,以启用权限管理</p><p>重启mongodb适用配置<br><code>sudo service mongodb restart</code></p><hr><hr><h2 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h2><p>（记得在防火墙打开6379端口）<br>如果想要允许远程访问的话，修改配置文件即可<br><code>sudo vim /etc/redis/redis.conf</code><br><code>bind 127.0.0.1改为bind 0.0.0.0</code><br>取消<code>requirepass foobared</code>注释，并且将foobared改为你的密码，如<code>requirepass &quot;your password&quot;</code><br>重启redis服务<br><code>sudo service redis-server restart</code></p><blockquote><p>修改之后在<code>redis-cli</code>中需要添加<code>-a &quot;your password&quot;</code>参数来启动(your password改为你设置的密码)</p></blockquote><h2 id="不添加该参数虽然也可以登录成功，但是没有任何操作权限。"><a href="#不添加该参数虽然也可以登录成功，但是没有任何操作权限。" class="headerlink" title="不添加该参数虽然也可以登录成功，但是没有任何操作权限。"></a>不添加该参数虽然也可以登录成功，但是没有任何操作权限。</h2><hr><h2 id="go配置"><a href="#go配置" class="headerlink" title="go配置"></a>go配置</h2><p>创建工作目录，配置环境变量和项目目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd $HMOE</span><br><span class="line">mkdir Applications Applications/Go</span><br><span class="line">mkdir Applications/Go/src Applications/Go/pkg Applications/Go/bin</span><br><span class="line">export GOROOT=$HOME/go</span><br><span class="line">export PATH=$GOROOT/bin:$PATH</span><br><span class="line">export GOPATH=$HOME/Applications/Go</span><br></pre></td></tr></table></figure></p><hr>]]></content>
      
      <categories>
          
          <category> Server </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>new Page</title>
      <link href="/2018/03/28/new-Page/"/>
      <url>/2018/03/28/new-Page/</url>
      <content type="html"><![CDATA[<p>久违的又一篇文章<br>为了某项目而学习go语言的记录大概会放在这里？<br>大概吧……</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.<span class="built_in">print</span>(<span class="string">"HelloWorld!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>first page</title>
      <link href="/2017/10/12/first-page/"/>
      <url>/2017/10/12/first-page/</url>
      <content type="html"><![CDATA[<p>嗯，总之就是简单的第一篇文章。</p><blockquote><p>听说有引用这种东西，所以拿来试试</p><footer><strong>简陋的小屋</strong><cite>Wuny</cite></footer></blockquote><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello world!"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
